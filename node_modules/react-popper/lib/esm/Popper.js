import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import deepEqual from "deep-equal";
import * as React from 'react';
import { createPopper } from '@popperjs/core';
import { ManagerReferenceNodeContext } from './Manager';
import { unwrapArray, setRef, shallowEqual } from './utils';
var initialPopperStyle = {
  top: 0,
  left: 0,
  opacity: 0,
  pointerEvents: 'none'
};
var initialArrowStyle = {};
export var InnerPopper = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(InnerPopper, _React$Component);

  var _super = _createSuper(InnerPopper);

  function InnerPopper() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      placement: undefined,
      styles: undefined,
      isReferenceHidden: undefined,
      hasPopperEscaped: undefined
    });

    _defineProperty(_assertThisInitialized(_this), "popperInstance", void 0);

    _defineProperty(_assertThisInitialized(_this), "popperNode", null);

    _defineProperty(_assertThisInitialized(_this), "arrowNode", null);

    _defineProperty(_assertThisInitialized(_this), "setPopperNode", function (popperNode) {
      if (!popperNode || _this.popperNode === popperNode) return;
      setRef(_this.props.innerRef, popperNode);
      _this.popperNode = popperNode;

      _this.updatePopperInstance();
    });

    _defineProperty(_assertThisInitialized(_this), "setArrowNode", function (arrowNode) {
      _this.arrowNode = arrowNode;
    });

    _defineProperty(_assertThisInitialized(_this), "updateStateModifier", {
      name: 'reactPopperState',
      enabled: true,
      phase: 'write',
      fn: function fn(_ref) {
        var state = _ref.state;
        var placement = state.placement,
            styles = state.styles,
            modifiersData = state.modifiersData;
        var isReferenceHidden;
        var hasPopperEscaped;

        if (modifiersData.hide) {
          isReferenceHidden = modifiersData.hide.isReferenceHidden;
          hasPopperEscaped = modifiersData.hide.hasPopperEscaped;
        }

        _this.setState({
          placement: placement,
          styles: styles,
          isReferenceHidden: isReferenceHidden,
          hasPopperEscaped: hasPopperEscaped
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getOptions", function () {
      var _this$props$modifiers = _this.props.modifiers,
          modifiers = _this$props$modifiers === void 0 ? [] : _this$props$modifiers;
      var arrowModifier = modifiers.find(function (modifier) {
        return modifier.name === 'arrow';
      });
      return {
        placement: _this.props.placement,
        strategy: _this.props.strategy,
        modifiers: [].concat(modifiers.filter(function (modifier) {
          return modifier.name !== 'arrow';
        }), [{
          name: 'arrow',
          enabled: !!_this.arrowNode,
          options: _extends({}, arrowModifier && arrowModifier.options, {
            element: _this.arrowNode
          })
        }, {
          name: 'applyStyles',
          enabled: false
        }, _this.updateStateModifier]),
        onFirstUpdate: _this.props.onFirstUpdate
      };
    });

    _defineProperty(_assertThisInitialized(_this), "getPopperStyle", function () {
      var computedInitialStyle = _extends({}, initialPopperStyle, {
        position: _this.props.strategy === 'fixed' ? 'fixed' : 'absolute'
      });

      return !_this.popperNode || !_this.state.styles ? computedInitialStyle : _this.state.styles.popper;
    });

    _defineProperty(_assertThisInitialized(_this), "getArrowStyle", function () {
      return !_this.arrowNode || !_this.state.styles ? initialArrowStyle : _this.state.styles.arrow;
    });

    _defineProperty(_assertThisInitialized(_this), "destroyPopperInstance", function () {
      if (!_this.popperInstance) return;

      _this.popperInstance.destroy();

      _this.popperInstance = null;
    });

    _defineProperty(_assertThisInitialized(_this), "updatePopperInstance", function () {
      _this.destroyPopperInstance();

      var _assertThisInitialize = _assertThisInitialized(_this),
          popperNode = _assertThisInitialize.popperNode;

      var referenceElement = _this.props.referenceElement;
      if (!referenceElement || !popperNode) return;
      _this.popperInstance = createPopper(referenceElement, popperNode, _this.getOptions());
    });

    _defineProperty(_assertThisInitialized(_this), "update", function () {
      if (_this.popperInstance) {
        return _this.popperInstance.update();
      } else {
        return Promise.resolve(null);
      }
    });

    return _this;
  }

  var _proto = InnerPopper.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // If the Popper.js reference element has changed, update the instance (destroy + create)
    if (this.props.referenceElement !== prevProps.referenceElement) {
      this.updatePopperInstance();
    } // If the Popper.js options have changed, set options


    if (this.props.placement !== prevProps.placement || this.props.strategy !== prevProps.strategy || !deepEqual(this.props.modifiers, prevProps.modifiers, {
      strict: true
    })) {
      // develop only check that modifiers isn't being updated needlessly
      if (process.env.NODE_ENV === "development") {
        if (this.props.modifiers !== prevProps.modifiers && this.props.modifiers != null && prevProps.modifiers != null && shallowEqual(this.props.modifiers, prevProps.modifiers)) {
          console.warn("'modifiers' prop reference updated even though all values appear the same.\nConsider memoizing the 'modifiers' object to avoid needless rendering.");
        }
      }

      if (this.popperInstance) {
        this.popperInstance.setOptions(this.getOptions());
      }
    } // A placement difference in state means popper determined a new placement
    // apart from the props value. By the time the popper element is rendered with
    // the new position Popper has already measured it, if the place change triggers
    // a size change it will result in a misaligned popper. So we schedule an update to be sure.


    if (prevState.placement !== this.state.placement) {
      this.update();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    setRef(this.props.innerRef, null);
    this.destroyPopperInstance();
  };

  _proto.render = function render() {
    var _this$state = this.state,
        placement = _this$state.placement,
        isReferenceHidden = _this$state.isReferenceHidden,
        hasPopperEscaped = _this$state.hasPopperEscaped;
    return unwrapArray(this.props.children)({
      ref: this.setPopperNode,
      style: this.getPopperStyle(),
      placement: placement,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped,
      update: this.update,
      arrowProps: {
        ref: this.setArrowNode,
        style: this.getArrowStyle()
      }
    });
  };

  return InnerPopper;
}(React.Component);

_defineProperty(InnerPopper, "defaultProps", {
  placement: 'bottom',
  strategy: 'absolute',
  modifiers: [],
  referenceElement: undefined
});

export default function Popper(_ref2) {
  var referenceElement = _ref2.referenceElement,
      props = _objectWithoutPropertiesLoose(_ref2, ["referenceElement"]);

  return /*#__PURE__*/React.createElement(ManagerReferenceNodeContext.Consumer, null, function (referenceNode) {
    return /*#__PURE__*/React.createElement(InnerPopper, {
      referenceElement: referenceElement !== undefined ? referenceElement : referenceNode,
      children: props.children,
      innerRef: props.innerRef,
      modifiers: props.modifiers,
      placement: props.placement,
      strategy: props.strategy,
      onFirstUpdate: props.onFirstUpdate
    });
  });
}